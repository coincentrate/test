<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MeowkyWay: Spiral Surge</title>
  <style>
    html, body {
      height: 100%; width: 100%;
      margin: 0; overflow: hidden;
      background: #0a0a2a;
    }
    body { background: #0a0a2a; }
    #gameCanvas {
      display: block;
      margin: auto;
      background: #141452;
      touch-action: none;
      width: 100vw;  /* Fill viewport */
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
    }
    #resetBtn {
      position:absolute; top:50%; left:50%;
      transform:translate(-50%,-50%);
      padding:10px 20px; font-size:18px;
      display:none; z-index:1;
    }
    #bgVideo { display: none; }
  </style>
</head>
<body>
  <!-- Video background (hidden, drawn in canvas) -->
  <video id="bgVideo" src="assets/background.mp4" loop autoplay muted playsinline style="display:none"></video>
  <canvas id="gameCanvas" width="1366" height="768"></canvas>
  <button id="resetBtn">Restart</button>
  <script>
    // Logic/game resolution (never changes!)
    const GAME_W = 1366, GAME_H = 768;
    const canvas = document.getElementById('gameCanvas');
    const ctx    = canvas.getContext('2d');
    // always draw at logic/game res
    const centerX = GAME_W/2, centerY = GAME_H/2;
    let displayScale = 1;

    // --- Menu/Touch buttons (virtual coords) ---
    const menuButtons = [
      {text: "Start",    x: centerX-100, y: centerY+30, w: 200, h: 50, action: ()=>{gameState='playing'; resetGame();}},
      {text: "Tutorial", x: centerX-100, y: centerY+100, w: 200, h: 50, action: ()=>{gameState='tutorial';}}
    ];
    const tutorialButton = [
      {text: "Back to Menu", x: centerX-100, y: GAME_H-100, w: 200, h: 50, action: ()=>{gameState='menu';}}
    ];

    // Video element for background
    const bgVideo = document.getElementById('bgVideo');
    bgVideo.play().catch(()=>{});
    document.body.addEventListener('click', ()=> {
      if (bgVideo.paused) bgVideo.play();
    });

    // --- Responsive canvas scale (CSS only) ---
    function resizeCanvas() {
      // CSS scale canvas to fill screen, preserving aspect
      const windowW = window.innerWidth, windowH = window.innerHeight;
      const scale = Math.min(windowW / GAME_W, windowH / GAME_H);
      canvas.style.width = (GAME_W * scale) + 'px';
      canvas.style.height = (GAME_H * scale) + 'px';
      displayScale = scale;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // asset lists
    const ASSETS = {
      cat: ['cat_idle.png'],
      obstacles: ['obstacle_rugpull.png','obstacle_fud.png','obstacle_jeeter.png'],
      powerUps: ['pu_double2.png','pu_double3.png','pu_invincible.png'],
      background: ['nebula_tile.png']
    };

    // loaded images
    const images = {};
    let toLoad = 0;
    for (let group in ASSETS) {
      ASSETS[group].forEach(file => {
        toLoad++;
        const img = new Image();
        img.src = `assets/${group}/${file}`;
        img.onload = () => { if (--toLoad === 0) startGame(); };
        img.onerror = () => { console.warn('Failed to load', file); if (--toLoad === 0) startGame(); };
        images[file] = img;
      });
    }

    // game vars
    const player = { x: centerX-32, y: GAME_H-100, width:64, height:102, vx:0, vy:0, speed:4 };
    let keys = {}, gameState = 'menu', frame = 0, score = 0, lastScoreFrame = 0, scoreMultiplier = 1,
        nextSpeedThreshold = 10, puTimers = {double2:0,double3:0,invincible:0}, lastPUFrame = -600, minPUInterval = 600,
        obstacleSpeedFactor = 1, puSpeedFactor = 1, playerSpeedIncrement = 1.08, obstacleSpeedIncrement = 1.04,
        maxPlayerSpeed = 8, maxObstacleFactor = 4, obstacles = [], powerUps = [], spiralAngle = 0,
        gameOver = false, bgAngle = 0;

    // Precompute spiral points
    const spiral = [];
    {
      const maxR = Math.sqrt(centerX*centerX + centerY*centerY);
      const pts = 100;
      for (let i = 0; i < pts; i++) spiral.push({ angle: i * 0.3, r: (i/pts)*maxR });
    }

    const resetBtn = document.getElementById('resetBtn');
    resetBtn.addEventListener('click', ()=>{
      resetBtn.style.display = 'none';
      gameOver = false;
      resetGame();
      gameState = 'playing';
      requestAnimationFrame(loop);
    });

    function startGame(){
      resetGame();         // <-- Reset everything to base values
      requestAnimationFrame(loop);
    }

    // --- SWIPE CONTROL (Mobile, mapped to virtual/game coords) ---
    let touchStartX = 0, touchStartY = 0;
    canvas.addEventListener('touchstart', e => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      // Map to canvas coords
      const rect = canvas.getBoundingClientRect();
      touchStartX = (t.clientX - rect.left) * (GAME_W / rect.width);
      touchStartY = (t.clientY - rect.top)  * (GAME_H / rect.height);
    });
    canvas.addEventListener('touchend', e => {
      if (e.changedTouches.length !== 1) return;
      const t = e.changedTouches[0];
      const rect = canvas.getBoundingClientRect();
      const endX = (t.clientX - rect.left) * (GAME_W / rect.width);
      const endY = (t.clientY - rect.top)  * (GAME_H / rect.height);

      // -- Menu/Buttons Touch --
      if (gameState === 'menu') {
        menuButtons.forEach(btn => {
          if (
            endX >= btn.x && endX <= btn.x + btn.w &&
            endY >= btn.y && endY <= btn.y + btn.h
          ) {
            btn.action();
          }
        });
        return; // don't process swipe for menu
      }
      if (gameState === 'tutorial') {
        tutorialButton.forEach(btn => {
          if (
            endX >= btn.x && endX <= btn.x + btn.w &&
            endY >= btn.y && endY <= btn.y + btn.h
          ) {
            btn.action();
          }
        });
        return; // don't process swipe for tutorial
      }

      const dx = endX - touchStartX;
      const dy = endY - touchStartY;
      const threshold = 30;
      if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
        if (dx > 0)      player.x += player.speed * 12;
        else             player.x -= player.speed * 12;
      } else if (Math.abs(dy) > threshold) {
        if (dy > 0)      player.y += player.speed * 12;
        else             player.y -= player.speed * 12;
      }
      player.x = Math.max(0, Math.min(GAME_W - player.width, player.x));
      player.y = Math.max(0, Math.min(GAME_H - player.height, player.y));
    });

    // input (desktop only)
    window.addEventListener('keydown', e => {
      if (gameState==='menu') return handleMenu(e);
      if (gameState==='tutorial') return handleTutorial(e);
      keys[e.code] = true; updateVel();
    });
    window.addEventListener('keyup', e => { keys[e.code] = false; updateVel(); });
    function handleMenu(e){ if (e.code==='Enter'){ gameState='playing'; resetGame(); } if (e.code==='KeyT'){ gameState='tutorial'; }}
    function handleTutorial(e){ if (e.code==='Enter'){ gameState='menu'; }}
    function updateVel(){
      player.vx=0; player.vy=0;
      if(keys['ArrowLeft']) player.vx=-player.speed;
      if(keys['ArrowRight']) player.vx=player.speed;
      if(keys['ArrowUp']) player.vy=-player.speed;
      if(keys['ArrowDown']) player.vy=player.speed;
    }

    // draw
    function drawMenu() {
      ctx.clearRect(0,0,GAME_W,GAME_H);
      ctx.fillStyle='#fff'; ctx.font='40px Arial'; ctx.textAlign='center';
      ctx.fillText('MEOWKYWAY: Spiral Surge', centerX, centerY-60);
      ctx.font='20px Arial'; ctx.fillText('Enter: Start    T: Tutorial', centerX, centerY);

      // Draw touch buttons
      menuButtons.forEach(btn => {
        ctx.fillStyle = '#2e3c70';
        ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
        ctx.strokeStyle = '#fff';
        ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
        ctx.fillStyle = '#fff';
        ctx.font = '28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(btn.text, btn.x + btn.w/2, btn.y + btn.h/2 + 10);
      });
    }

    function drawTutorial() {
      ctx.clearRect(0,0,GAME_W,GAME_H);
      ctx.fillStyle='#fff'; ctx.font='30px Arial'; ctx.textAlign='center'; ctx.fillText('Tutorial', centerX,100);
      ctx.font='18px Arial'; ctx.textAlign='left';
      ['Arrow keys/swipe: move cat', 'Avoid obstacles', 'Collect power-ups:',
        '- Pink (2X): double score', '- Purple (3X): triple score',
        '- Gold (INV): invincibility', 'Score +1 per sec']
        .forEach((l,i)=>ctx.fillText(l,50,160+i*30));
      ctx.font='20px Arial'; ctx.textAlign='center'; ctx.fillText('Enter/Back: Back to Menu', centerX, GAME_H-60);

      // Draw back button
      tutorialButton.forEach(btn => {
        ctx.fillStyle = '#2e3c70';
        ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
        ctx.strokeStyle = '#fff';
        ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
        ctx.fillStyle = '#fff';
        ctx.font = '26px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(btn.text, btn.x + btn.w/2, btn.y + btn.h/2 + 8);
      });
    }

    function drawBackground(){
      if (bgVideo.readyState >= 2 && !bgVideo.paused) {
        ctx.drawImage(bgVideo, 0, 0, GAME_W, GAME_H);
      } else {
        ctx.fillStyle = "#141452";
        ctx.fillRect(0,0,GAME_W,GAME_H);
      }
    }

    function drawSpiral(){ spiralAngle += 0.02;
      ctx.strokeStyle='rgba(255,255,255,0.1)'; ctx.lineWidth=1;
      spiral.forEach(pt=>{
        const ang = pt.angle + spiralAngle;
        const x = centerX + Math.cos(ang)*pt.r;
        const y = centerY + Math.sin(ang)*pt.r;
        ctx.beginPath(); ctx.arc(x,y,1,0,2*Math.PI); ctx.stroke();
      });
    }
    function drawPlayer(){
      ctx.drawImage(images['cat_idle.png'], player.x, player.y, player.width, player.height);
    }
    function drawObstacle(o){ ctx.drawImage(images['obstacle_'+o.type+'.png'], o.x, o.y, o.size, o.size); }
    function drawPowerUp(p){ ctx.drawImage(images['pu_'+p.type+'.png'], p.x, p.y, p.size, p.size); }

    class ObstacleClass { constructor(){ this.size=64; this.speed=3.5*obstacleSpeedFactor;
        const o=Math.random();
        if(o<0.2){ this.x=centerX-this.size/2; this.y=centerY-this.size/2; }
        else if(o<0.4){ this.x=Math.random()*(GAME_W-this.size); this.y=-this.size; }
        else if(o<0.6){ this.x=Math.random()*(GAME_W-this.size); this.y=GAME_H; }
        else if(o<0.8){ this.x=-this.size; this.y=Math.random()*(GAME_H-this.size); }
        else { this.x=GAME_W; this.y=Math.random()*(GAME_H-this.size); }
        const tx=player.x+player.width/2, ty=player.y+player.height/2;
        const ang=Math.atan2(ty-(this.y+this.size/2), tx-(this.x+this.size/2));
        this.vx=Math.cos(ang)*this.speed; this.vy=Math.sin(ang)*this.speed;
        this.type = Math.random()<0.33?'rugpull':(Math.random()<0.66?'fud':'jeeter'); }
      update(){ this.x+=this.vx; this.y+=this.vy; }
      offScreen(){ return this.x+this.size<0||this.x>GAME_W||this.y+this.size<0||this.y>GAME_H; }
    }
    class PowerUpClass { constructor(type){ this.size=64; this.speed=2.5*puSpeedFactor;
        this.x=centerX-this.size/2; this.y=centerY-this.size/2;
        const tx=player.x+player.width/2, ty=player.y+player.height/2;
        const ang=Math.atan2(ty-centerY, tx-centerX);
        this.vx=Math.cos(ang)*this.speed; this.vy=Math.sin(ang)*this.speed;
        this.type=type; }
      update(){ this.x+=this.vx; this.y+=this.vy; }
      offScreen(){ return this.x+this.size<0||this.x>GAME_W||this.y+this.size<0||this.y>GAME_H; }
    }

    function resetGame(){ obstacles=[]; powerUps=[]; frame=0; score=0; lastScoreFrame=0; scoreMultiplier=1;
      nextSpeedThreshold=10; puTimers={double2:0,double3:0,invincible:0}; lastPUFrame=-600;
      obstacleSpeedFactor=1; puSpeedFactor=1; player.speed=4; player.x=centerX-32; player.y=GAME_H-100;
      gameOver=false; resetBtn.style.display='none'; }

    function checkCollisions(){ obstacles.forEach((o,i)=>{
        if(puTimers.invincible<=0 && player.x<o.x+o.size && player.x+player.width>o.x &&
           player.y<o.y+o.size && player.y+player.height>o.y) gameOver=true; });
      powerUps.forEach((p,i)=>{
        if(player.x<p.x+p.size && player.x+player.width>p.x && player.y<p.y+p.size && player.y+player.height>p.y){
          if(p.type==='double2') puTimers.double2=600;
          if(p.type==='double3') puTimers.double3=900;
          if(p.type==='invincible') puTimers.invincible=600;
          powerUps.splice(i,1);
        }
      }); }

    function loop(){
      if(gameState==='menu'){ drawMenu(); requestAnimationFrame(loop); return; }
      if(gameState==='tutorial'){ drawTutorial(); requestAnimationFrame(loop); return; }
      if(gameOver){ ctx.fillStyle='red'; ctx.font='40px Arial'; const txt='GAME OVER', tw=ctx.measureText(txt).width; ctx.fillText(txt,(GAME_W-tw)/2,GAME_H/2); resetBtn.style.display='block'; return; }
      ctx.clearRect(0,0,GAME_W,GAME_H);
      drawBackground(); drawSpiral(); frame++;
      if(keys['ArrowLeft']) player.x -= player.speed;
      if(keys['ArrowRight']) player.x += player.speed;
      if(keys['ArrowUp']) player.y -= player.speed;
      if(keys['ArrowDown']) player.y += player.speed;
      player.x = Math.max(0, Math.min(GAME_W-player.width, player.x));
      player.y = Math.max(0, Math.min(GAME_H-player.height, player.y));
      if(frame-lastScoreFrame>=60){ score+=scoreMultiplier; lastScoreFrame=frame; }
      if(score>=nextSpeedThreshold){ player.speed=Math.min(maxPlayerSpeed, player.speed*playerSpeedIncrement);
        obstacleSpeedFactor=Math.min(maxObstacleFactor, obstacleSpeedFactor*obstacleSpeedIncrement);
        puSpeedFactor=Math.min(maxObstacleFactor, puSpeedFactor*obstacleSpeedIncrement);
        nextSpeedThreshold+=10; }
      scoreMultiplier = puTimers.double3>0?3:puTimers.double2>0?2:1;
      if(puTimers.double2>0) puTimers.double2--; if(puTimers.double3>0) puTimers.double3--; if(puTimers.invincible>0) puTimers.invincible--;
      const spawnI = Math.max(30,120-Math.floor(frame/600)); if(frame%spawnI===0) obstacles.push(new ObstacleClass());
      if(frame-lastPUFrame>=minPUInterval&&Math.random()<0.01){ const types=['double2','double3','invincible']; powerUps.push(new PowerUpClass(types[Math.floor(Math.random()*types.length)])); lastPUFrame=frame; }
      obstacles.forEach((o,i)=>{ o.update(); drawObstacle(o);
